# ESP8266 频谱仪

能用就行。

## [<查看英文版 view English version>](./README.md)

## 演示

<video controls>
  <source src="./demo/video_2023-05-03_15-26-10.mp4" type="video/mp4">
  你的浏览器不支持video标签
</video>

[点击查看视频](./demo/video_2023-05-03_15-26-10.mp4)

## 文档

### 怎么用？

1. 安装 `platform-io`.
2. 安装 `python` 和 `pyaudio`, `numpy`, `matplotlib` 第三方库。
3. 根据你的 wifi 修改相关代码。
4. 编译固件并烧写进 `esp8266-12f`。
5. 焊接 4 个 MAX7219 8*8 LED 矩阵模块:

```
ESP8266
    |
    V
[ 矩阵  1]-DOUT > DIN-[ 矩阵   2]-DOUT > DIN-[ 矩阵   3]-DOUT > DIN-[ 矩阵  4]
          -CS   >  CS-          -CS   >  CS-          -CS   >  CS-
          -CLK  > CLK-          -CLK  > CLK-          -CLK  > CLK-
          -VCC  > VCC-          -VCC  > VCC-          -VCC  > VCC-
          -GND  > GND-          -GND  > GND-          -GND  > GND-
<-----------  左通道  ---------->            <-----------  右通道  ---------->
高频                         低频            低频                         高频
```

6. 连接第一个模块的 `VCC - 5V`, `GND - GND`, `DIN - D7`, `CS - D6`, `CLK - D5`。

> 提示: 上电前检查 VCC-GND 是否短路。

7. 上电，并运行 `server/main.py`。
8. 如果 `server/main.py` 崩溃, 请修改第 29 行的 `input_device_index`, 或者提交 issue。
9. 运行 `pavucontrol`, 在 `record` 选项卡中, 修改 `ALSA plug-in [python xx]: ALSA Capture` 的录音设备。
10. 享受吧！

### 音频服务器 `server/main.py`

此代码创建一个实时音频可视化工具。 它导入必要的库，设置块大小和采样率，连接到套接字，然后找到音频输入的设备索引。然后它会创建一个带有两个轴的图，一个用于左通道，一个用于右通道。然后它从流中读取音频数据，将其分成左右声道，并对每个声道执行傅立叶变换。然后它采用傅里叶变换的绝对值并对其应用对数刻度。然后它从每个频率范围中取最大值并将其存储在一个数组中。然后它将绘图的 y 数据设置为数组值，并通过套接字发送数组值。最后，它绘制绘图并刷新事件。

1. 导入所需的库：`pyaudio`、`numpy`、`matplotlib`、`math` 和 `socket`。
2. 设置 `CHUNK_SIZE` 和 `SAMPLING_RATE` 常量以从麦克风读取音频数据。
3. 创建一个套接字并连接到特定的IP地址和端口，用于将音频数据发送到另一个设备。
4. 创建 `pyaudio.PyAudio()` 类的实例并循环遍历所有可用的音频输入设备以找到合适的设备来录制音频。
5. 使用 `matplotlib.pyplot.subplots()` 方法创建一个有两个轴的图，一个用于左通道，一个用于右通道。
6. 使用 `numpy.linspace()` 方法生成一个由 0 到 16 之间的 16 个等距数字组成的序列，用作绘图的 x 轴数据。
7. 为绘图初始化两条线，一条用于左通道，一根用于右通道，每条线包含长度为 16 的随机 y 轴数据。
8. 为每个子图的 x 轴和 y 轴设置限制和标签。
9. 使用 `matplotlib.pyplot.show()` 方法显示绘图。
10. 初始化四个长度为16的数组，存放特定频率范围内音频数据的最大值。
11. 初始化一个长度为 64 的 `bytearray` ，用于通过套接字发送音频数据。
12. 进入一个循环，使用 `stream.read(CHUNK_SIZE)` 方法从麦克风重复读取一大块音频数据。
13. 将音频数据转换为 32 位浮点数据的 numpy 数组。
14. 将音频数据分成两路，一路为左路，一路为右路。
15. 对每个通道进行快速傅里叶变换（FFT），将音频数据从时域转换到频域。
16. 取 FFT 结果的绝对值，并使用 `numpy.log10()` 方法对它们应用对数刻度。
17. 在左右声道的 16 个频率范围内分别找出最大值，并将它们存储在单独的数组中。
18. 使用存储在数组中的最大值更新绘图的 y 轴数据。
19. 使用阈值机制将每个数组的最大值限制为 7。
20. 将数组中的最大值以及未过滤的最大值存储在`bytearray`中。
21. 通过套接字发送 `bytearray`。
22. 使用 `matplotlib.pyplot.draw()` 和 `matplotlib.pyplot.flush_events()` 方法重新绘制绘图并刷新所有事件。

这个过程在一个循环中不断重复，产生一个实时音频可视化器，显示正在记录的音频数据中特定频率范围的幅度。 可视化工具还通过套接字连接将此数据发送到另一个设备。

### 显示屏 `src/main.cpp`

此代码建立到 WiFi 网络的连接，然后在端口 1234 上侦听 UDP 数据包。当它收到数据包时，它会在显示器上绘制数据图。

1. 代码包括连接到 WiFi 网络、使用 SPI 和 I2C 以及在显示器上显示数据所需的库。
2. 定义要连接的 WiFi 网络的 SSID 和密码。
3. 为连接设置静态IP、网关、子网和DNS。
4. 初始化显示。
5. 在 `setup()` 函数中，它启动串行连接，初始化显示，连接到 WiFi 网络，并开始在端口 1234 上侦听 UDP 数据包。
6. 在 `loop()` 函数中，它检查是否有可用的 UDP 数据包。
7. 如果有，它将数据包读入缓冲区，检查数据包大小是否为 64 字节，然后在显示器上绘制数据图。
